// Code generated by go2go; DO NOT EDIT.


//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:1
package catch

//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:1
import (
//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:1
 "errors"
//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:1
 "fmt"
//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:1
 "strconv"
//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:1
 "testing"
//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:1
)

//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:10
func validate(i int) error {
	if i > 100 {
		return errors.New("exceeded max")
	}

	return nil
}

func TestCatch(t *testing.T) {
	cases := []struct {
		name      string
		getString func() (string, error)
		i         int
		errString string
	}{
		{
			name: "valid string without error",
			getString: func() (string, error) {
				return "100", nil
			},
			i: 100,
		},
		{
			name: "valid string with error",
			getString: func() (string, error) {
				return "100", errors.New("dummy error")
			},
			errString: "get string: dummy error",
		},
		{
			name: "invalid string",
			getString: func() (string, error) {
				return "a", nil
			},
			errString: `convert integer: strconv.Atoi: parsing "a": invalid syntax`,
		},
		{
			name: "invalid number",
			getString: func() (string, error) {
				return "101", nil
			},
			errString: "validate: exceeded max",
		},
	}

	for _, c := range cases {
		t.Run(c.name, func(t *testing.T) {
			i, err := func() (_ int, err error) {
				defer Catch(&err)

				s := instantiate୦୦Try୦string(c.getString()).Wrap("get string").Must()
				i := instantiate୦୦Try୦int(strconv.Atoi(s)).Wrap("convert integer").Must()

				DoAndWrap(validate(i), "validate")

				return i, nil
			}()

			if i != c.i {
				t.Errorf("expected %d, got %d", c.i, i)
			}

			if err == nil && c.errString != "" {
				t.Errorf("expected error(%s), got error(nil)", c.errString)
			}

			if err != nil && err.Error() != c.errString {
				t.Errorf("expected error(%s), got error(%v)", c.errString, err)
			}
		})
	}
}

//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:84
type catchableError struct {
	err error
}

func (e *catchableError) Error() string {
	return fmt.Sprintf("catchable error: %v", e.err)
}

func (e *catchableError) Unwrap() error {
	return e.err
}

func Do(err error) {
	if err != nil {
		panic(&catchableError{err: err})
	}
}

func DoAndWrap(err error, msg string) {
	if err != nil {
		panic(&catchableError{err: fmt.Errorf("%s: %w", msg, err)})
	}
}

//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:136
func Catch(err *error) {
	switch r := recover().(type) {
	case nil:
		return
	case *catchableError:
		*err = r.err
	default:
		panic(r)
	}
}
//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:113
func instantiate୦୦Try୦string(val string, err error) instantiate୦୦Optional୦string {
	return instantiate୦୦Optional୦string{val: val, err: err}
}
//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:113
func instantiate୦୦Try୦int(val int, err error) instantiate୦୦Optional୦int {
	return instantiate୦୦Optional୦int{val: val, err: err}
}

//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:115
type instantiate୦୦Optional୦string struct {
//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:109
 val string
									err error
}

//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:117
func (o instantiate୦୦Optional୦string,) Wrap(msg string) instantiate୦୦Optional୦string {
	if o.err != nil {
		return instantiate୦୦Optional୦string{val: o.val, err: fmt.Errorf("%s: %w", msg, o.err)}
	}
	return instantiate୦୦Optional୦string{val: o.val, err: o.err}
}

func (o instantiate୦୦Optional୦string,) Get() (string, error) {
	return o.val, o.err
}

func (o instantiate୦୦Optional୦string,) Must() string {
	if o.err != nil {
		panic(&catchableError{err: o.err})
	}
	return o.val
}

//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:133
type instantiate୦୦Optional୦int struct {
//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:109
 val int
									err error
}

//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:117
func (o instantiate୦୦Optional୦int,) Wrap(msg string) instantiate୦୦Optional୦int {
	if o.err != nil {
		return instantiate୦୦Optional୦int{val: o.val, err: fmt.Errorf("%s: %w", msg, o.err)}
	}
	return instantiate୦୦Optional୦int{val: o.val, err: o.err}
}

func (o instantiate୦୦Optional୦int,) Get() (int, error) {
	return o.val, o.err
}

func (o instantiate୦୦Optional୦int,) Must() int {
	if o.err != nil {
		panic(&catchableError{err: o.err})
	}
	return o.val
}

//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:133
type Importable୦ int

//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:133
var _ = errors.As
//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:133
var _ = fmt.Errorf
//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:133
var _ = strconv.AppendBool
//line /Users/li/.ghq/github.com/li-go/catch/catch_test.go2:133
var _ = testing.AllocsPerRun
